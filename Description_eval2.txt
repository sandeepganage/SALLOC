In the second phase of GSoC 2017, I have extended the functionality of the basic version of an arena allocator I implemented for phase-1.

The arena now supports push_back() and reserve() operations for vectors. In addition, it also allows to allocate and manage multiple vectors on the arena. These vectors are shared across threads, so multiple threads can push elements in to the vectors in parallel.

A brief outline of the implementation is given below:
1. An array of Chunks of size 'capacity' is preallocated on the GPU from the CPU using a call to cudaMalloc().

2. A 'chunk' is an array of scalars of a predetermined size, CHUNK_SZ. 

3. The push_back() operation pushes a scalar to a location in a chunk.

4. A shared variable 'count', keeps track of the next free location inside a chunk where the insertion can take place. 'count' is incremented using atomicAdd to avoid data race.

5. Similarly, 'chunkCount' is used to keep track of whether the capacity of the arena is exhausted or not.

6. If a chunk gets full, but there are other chunks available, then a new chunk is exposed to the user program by incrementing the value of 'chunkCount' atomically and returning the address of the new chunk.

7. More than one vectors can be allocated and maintained on the arena. Each new vector starts at a new chunk.

8. Outside the arena, on the GPU, the address of the starting chunk of each vector is stored, as meta-data. These offset addresses are visible to all threads. 

9. When push_back() is to be performed on a specified vector, each thread first reads-off the address of the chunk for the vector and then proceeds to push_back() into
the correct chunk.

10. In cases when a vector spans across multiple chunks, a fully free (new) chunk is requested each time a vector spills to a new chunk. 
This is done to ensure that a chunk contains the elements of one vector alone. This helps in preventing the data of different vectors from being mixed.
The different chunks of a vector are stung together in a linked-list.


11. The reserve() operation allocates the requested number of chunks for a vector in the arena.

12. 'chunkCount' is incremented by the number of chunks to be reserved, starting at the initial chunk for a vector. 

13. Since 'chunkCount' points to the starting of the fully free chunks in the arena, setting its value appropriately allows
us to set aside the specified number of chunks for a vector.

14. A vector can be traversed by starting at the specified address offset and going over the chunks following the links between chunks.
